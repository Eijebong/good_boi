
pub fn decode(code: u8) -> Instruction {
    use Instruction::*;
    use Operand::*;
    use self::Reg8::*;
    use self::Reg16::*;
    use self::Cond::*;
    
    match code {
        0x00 => Nop,
        0x01 => Ld(Reg16(BC), Imm16),
        0x02 => Ld(RegRef16(BC), Reg8(A)),
        0x03 => Inc(Reg16(BC)),
        0x04 => Inc(Reg8(B)),
        0x05 => Dec(Reg8(B)),
        0x06 => Ld(Reg8(B), Imm8),
        0x07 => Rlca,
        0x08 => Ld(Imm16Ref, Reg16(SP)),
        0x09 => Add(Reg16(HL), Reg16(BC)),
        0x0A => Ld(Reg8(A), RegRef16(BC)),
        0x0B => Dec(Reg16(BC)),
        0x0C => Inc(Reg8(C)),
        0x0D => Dec(Reg8(C)),
        0x0E => Ld(Reg8(C), Imm8),
        0x0F => Rrca,

        0x10 => Stop,
        0x11 => Ld(Reg16(DE), Imm16),
        0x12 => Ld(RegRef16(DE), Reg8(A)),
        0x13 => Inc(Reg16(DE)),
        0x14 => Inc(Reg8(D)),
        0x15 => Dec(Reg8(D)),
        0x16 => Ld(Reg8(D), Imm8),
        0x17 => Rla,
        0x18 => Jr(Always, Imm8),
        0x19 => Add(Reg16(HL), Reg16(DE)),
        0x1A => Ld(Reg8(A), RegRef16(DE)),
        0x1B => Dec(Reg16(DE)),
        0x1C => Inc(Reg8(E)),
        0x1D => Dec(Reg8(E)),
        0x1E => Ld(Reg8(E), Imm8),
        0x1F => Rra,

        0x20 => Jr(ZReset, Imm8),
        0x21 => Ld(Reg16(HL), Imm16),
        0x22 => Ld(RegRef16(HLInc), Reg8(A)),
        0x23 => Inc(Reg16(HL)),
        0x24 => Inc(Reg8(H)),
        0x25 => Dec(Reg8(H)),
        0x26 => Ld(Reg8(H), Imm8),
        0x27 => Daa,
        0x28 => Jr(ZSet, Imm8),
        0x29 => Add(Reg16(HL), Reg16(HL)),
        0x2A => Ld(Reg8(A), RegRef16(HLInc)),
        0x2B => Dec(Reg16(HL)),
        0x2C => Inc(Reg8(L)),
        0x2D => Dec(Reg8(L)),
        0x2E => Ld(Reg8(L), Imm8),
        0x2F => Cpl,

        0x30 => Jr(CReset, Imm8),
        0x31 => Ld(Reg16(SP), Imm16),
        0x32 => Ld(RegRef16(HLDec), Reg8(A)),
        0x33 => Inc(Reg16(SP)),
        0x34 => Inc(RegRef16(HL)),
        0x35 => Dec(RegRef16(HL)),
        0x36 => Ld(RegRef16(HL), Imm8),
        0x37 => Scf,
        0x38 => Jr(CSet, Imm8),
        0x39 => Add(Reg16(HL), Reg16(SP)),
        0x3A => Ld(Reg8(E), RegRef16(HLDec)),
        0x3B => Dec(Reg16(SP)),
        0x3C => Inc(Reg8(A)),
        0x3D => Dec(Reg8(A)),
        0x3E => Ld(Reg8(A), Imm8),
        0x3F => Ccf,

        0x40 => Ld(Reg8(B), Reg8(B)),
        0x41 => Ld(Reg8(B), Reg8(C)),
        0x42 => Ld(Reg8(B), Reg8(D)),
        0x43 => Ld(Reg8(B), Reg8(E)),
        0x44 => Ld(Reg8(B), Reg8(H)),
        0x45 => Ld(Reg8(B), Reg8(L)),
        0x46 => Ld(Reg8(B), RegRef16(HL)),
        0x47 => Ld(Reg8(B), Reg8(A)),
        0x48 => Ld(Reg8(C), Reg8(B)),
        0x49 => Ld(Reg8(C), Reg8(C)),
        0x4A => Ld(Reg8(C), Reg8(D)),
        0x4B => Ld(Reg8(C), Reg8(E)),
        0x4C => Ld(Reg8(C), Reg8(H)),
        0x4D => Ld(Reg8(C), Reg8(L)),
        0x4E => Ld(Reg8(C), RegRef16(HL)),
        0x4F => Ld(Reg8(C), Reg8(A)),

        0x50 => Ld(Reg8(D), Reg8(B)),
        0x51 => Ld(Reg8(D), Reg8(C)),
        0x52 => Ld(Reg8(D), Reg8(D)),
        0x53 => Ld(Reg8(D), Reg8(E)),
        0x54 => Ld(Reg8(D), Reg8(H)),
        0x55 => Ld(Reg8(D), Reg8(L)),
        0x56 => Ld(Reg8(D), RegRef16(HL)),
        0x57 => Ld(Reg8(D), Reg8(A)),
        0x58 => Ld(Reg8(E), Reg8(B)),
        0x59 => Ld(Reg8(E), Reg8(C)),
        0x5A => Ld(Reg8(E), Reg8(D)),
        0x5B => Ld(Reg8(E), Reg8(E)),
        0x5C => Ld(Reg8(E), Reg8(H)),
        0x5D => Ld(Reg8(E), Reg8(L)),
        0x5E => Ld(Reg8(E), RegRef16(HL)),
        0x5F => Ld(Reg8(E), Reg8(A)),

        0x60 => Ld(Reg8(H), Reg8(B)),
        0x61 => Ld(Reg8(H), Reg8(C)),
        0x62 => Ld(Reg8(H), Reg8(D)),
        0x63 => Ld(Reg8(H), Reg8(E)),
        0x64 => Ld(Reg8(H), Reg8(H)),
        0x65 => Ld(Reg8(H), Reg8(L)),
        0x66 => Ld(Reg8(H), RegRef16(HL)),
        0x67 => Ld(Reg8(H), Reg8(A)),
        0x68 => Ld(Reg8(L), Reg8(B)),
        0x69 => Ld(Reg8(L), Reg8(C)),
        0x6A => Ld(Reg8(L), Reg8(D)),
        0x6B => Ld(Reg8(L), Reg8(E)),
        0x6C => Ld(Reg8(L), Reg8(H)),
        0x6D => Ld(Reg8(L), Reg8(L)),
        0x6E => Ld(Reg8(L), RegRef16(HL)),
        0x6F => Ld(Reg8(L), Reg8(A)),

        0x70 => Ld(RegRef16(HL), Reg8(B)),
        0x71 => Ld(RegRef16(HL), Reg8(C)),
        0x72 => Ld(RegRef16(HL), Reg8(D)),
        0x73 => Ld(RegRef16(HL), Reg8(E)),
        0x74 => Ld(RegRef16(HL), Reg8(H)),
        0x75 => Ld(RegRef16(HL), Reg8(L)),
        0x76 => Halt,
        0x77 => Ld(RegRef16(HL), Reg8(A)),
        0x78 => Ld(Reg8(A), Reg8(B)),
        0x79 => Ld(Reg8(A), Reg8(C)),
        0x7A => Ld(Reg8(A), Reg8(D)),
        0x7B => Ld(Reg8(A), Reg8(E)),
        0x7C => Ld(Reg8(A), Reg8(H)),
        0x7D => Ld(Reg8(A), Reg8(L)),
        0x7E => Ld(Reg8(A), RegRef16(HL)),
        0x7F => Ld(Reg8(A), Reg8(A)),

        0x80 => Add(Reg8(A), Reg8(B)),
        0x81 => Add(Reg8(A), Reg8(C)),
        0x82 => Add(Reg8(A), Reg8(D)),
        0x83 => Add(Reg8(A), Reg8(E)),
        0x84 => Add(Reg8(A), Reg8(H)),
        0x85 => Add(Reg8(A), Reg8(L)),
        0x86 => Add(Reg8(A), RegRef16(HL)),
        0x87 => Add(Reg8(A), Reg8(A)),

        0x88 => Adc(Reg8(B)),
        0x89 => Adc(Reg8(C)),
        0x8A => Adc(Reg8(D)),
        0x8B => Adc(Reg8(E)),
        0x8C => Adc(Reg8(H)),
        0x8D => Adc(Reg8(L)),
        0x8E => Adc(RegRef16(HL)),
        0x8F => Adc(Reg8(A)),

        0x90 => Sub(Reg8(B)),
        0x91 => Sub(Reg8(C)),
        0x92 => Sub(Reg8(D)),
        0x93 => Sub(Reg8(E)),
        0x94 => Sub(Reg8(H)),
        0x95 => Sub(Reg8(L)),
        0x96 => Sub(RegRef16(HL)),
        0x97 => Sub(Reg8(A)),

        0x98 => Sbc(Reg8(A), Reg8(B)),
        0x99 => Sbc(Reg8(A), Reg8(C)),
        0x9A => Sbc(Reg8(A), Reg8(D)),
        0x9B => Sbc(Reg8(A), Reg8(E)),
        0x9C => Sbc(Reg8(A), Reg8(H)),
        0x9D => Sbc(Reg8(A), Reg8(L)),
        0x9E => Sbc(Reg8(A), RegRef16(HL)),
        0x9F => Sbc(Reg8(A), Reg8(A)),

        0xA0 => And(Reg8(B)),
        0xA1 => And(Reg8(C)),
        0xA2 => And(Reg8(D)),
        0xA3 => And(Reg8(E)),
        0xA4 => And(Reg8(H)),
        0xA5 => And(Reg8(L)),
        0xA6 => And(RegRef16(HL)),
        0xA7 => And(Reg8(A)),

        0xA8 => Xor(Reg8(B)),
        0xA9 => Xor(Reg8(C)),
        0xAA => Xor(Reg8(D)),
        0xAB => Xor(Reg8(E)),
        0xAC => Xor(Reg8(H)),
        0xAD => Xor(Reg8(L)),
        0xAE => Xor(RegRef16(HL)),
        0xAF => Xor(Reg8(A)),

        0xB0 => Or(Reg8(B)),
        0xB1 => Or(Reg8(C)),
        0xB2 => Or(Reg8(D)),
        0xB3 => Or(Reg8(E)),
        0xB4 => Or(Reg8(H)),
        0xB5 => Or(Reg8(L)),
        0xB6 => Or(RegRef16(HL)),
        0xB7 => Or(Reg8(A)),

        0xB8 => Cp(Reg8(B)),
        0xB9 => Cp(Reg8(C)),
        0xBA => Cp(Reg8(D)),
        0xBB => Cp(Reg8(E)),
        0xBC => Cp(Reg8(H)),
        0xBD => Cp(Reg8(L)),
        0xBE => Cp(RegRef16(HL)),
        0xBF => Cp(Reg8(A)),

        0xC0 => Ret(ZReset),
        0xC1 => Pop(BC),
        0xC2 => Jp(ZReset, Imm16),
        0xC3 => Jp(Always, Imm16),
        0xC4 => Call(ZReset, Imm16),
        0xC5 => Push(BC),
        0xC6 => Add(Reg8(A), Imm8),
        0xC7 => Rst(0x00),
        0xC8 => Ret(ZSet),
        0xC9 => Ret(Always),
        0xCA => Jp(ZSet, Imm16),
        0xCB => Extended,
        0xCC => Call(ZSet, Imm16),
        0xCD => Call(Always, Imm16),
        0xCE => Adc(Imm8),
        0xCF => Rst(0x08),

        0xD0 => Ret(CReset),
        0xD1 => Pop(DE),
        0xD2 => Jp(CReset, Imm16),
        0xD3 => Invalid,
        0xD4 => Call(CReset, Imm16),
        0xD5 => Push(DE),
        0xD6 => Sub(Imm8),
        0xD7 => Rst(0x10),
        0xD8 => Ret(CSet),
        0xD9 => Reti,
        0xDA => Jp(CSet, Imm16),
        0xDB => Invalid,
        0xDC => Call(CSet, Imm16),
        0xDD => Invalid,
        0xDE => Sbc(Reg8(A), Imm8),
        0xDF => Rst(0x18),
        
        0xE0 => Ldh(Imm8Ref, Reg8(A)),
        0xE1 => Pop(HL),
        0xE2 => Ld(RegRef8(C), Reg8(A)),
        0xE3 => Invalid,
        0xE4 => Invalid,
        0xE5 => Push(HL),
        0xE6 => And(Imm8),
        0xE7 => Rst(0x20),
        0xE8 => Add(Reg16(SP), Imm8),
        0xE9 => Jp(Always, RegRef16(HL)),
        0xEA => Ld(Imm16Ref, Reg8(A)),
        0xEB => Invalid,
        0xEC => Invalid,
        0xED => Invalid,
        0xEE => Xor(Imm8),
        0xEF => Rst(0x28),

        0xF0 => Ldh(Reg8(A), Imm8Ref),
        0xF1 => Pop(AF),
        0xF2 => Ld(Reg8(A), RegRef8(C)),
        0xF3 => Di,
        0xF4 => Invalid,
        0xF5 => Push(AF),
        0xF6 => Or(Imm8),
        0xF7 => Rst(0x30),
        0xF8 => Ldhl,
        0xF9 => Ld(Reg16(SP), Reg16(HL)),
        0xFA => Ld(Reg8(A), Imm16Ref),
        0xFB => Ei,
        0xFC => Invalid,
        0xFD => Invalid,
        0xFE => Cp(Imm8),
        0xFF => Rst(0x38),
    }
}

pub fn decode_extended(code: u8) -> ExtendedInstruction {
    use ExtendedInstruction::*;
    use Operand::*;
    use self::Reg8::*;
    use self::Reg16::*;
    
    match code {
        0x00 => Rlc(Reg8(B)),
        0x01 => Rlc(Reg8(C)),
        0x02 => Rlc(Reg8(D)),
        0x03 => Rlc(Reg8(E)),
        0x04 => Rlc(Reg8(H)),
        0x05 => Rlc(Reg8(L)),
        0x06 => Rlc(RegRef16(HL)),
        0x07 => Rlc(Reg8(A)),
        0x08 => Rrc(Reg8(B)),
        0x09 => Rrc(Reg8(C)),
        0x0A => Rrc(Reg8(D)),
        0x0B => Rrc(Reg8(E)),
        0x0C => Rrc(Reg8(H)),
        0x0D => Rrc(Reg8(L)),
        0x0E => Rrc(RegRef16(HL)),
        0x0F => Rrc(Reg8(A)),
        0x10 => Rl(Reg8(B)),
        0x11 => Rl(Reg8(C)),
        0x12 => Rl(Reg8(D)),
        0x13 => Rl(Reg8(E)),
        0x14 => Rl(Reg8(H)),
        0x15 => Rl(Reg8(L)),
        0x16 => Rl(RegRef16(HL)),
        0x17 => Rl(Reg8(A)),
        0x18 => Rr(Reg8(B)),
        0x19 => Rr(Reg8(C)),
        0x1A => Rr(Reg8(D)),
        0x1B => Rr(Reg8(E)),
        0x1C => Rr(Reg8(H)),
        0x1D => Rr(Reg8(L)),
        0x1E => Rr(RegRef16(HL)),
        0x1F => Rr(Reg8(A)),
        0x20 => Sla(Reg8(B)),
        0x21 => Sla(Reg8(C)),
        0x22 => Sla(Reg8(D)),
        0x23 => Sla(Reg8(E)),
        0x24 => Sla(Reg8(H)),
        0x25 => Sla(Reg8(L)),
        0x26 => Sla(RegRef16(HL)),
        0x27 => Sla(Reg8(A)),
        0x28 => Sra(Reg8(B)),
        0x29 => Sra(Reg8(C)),
        0x2A => Sra(Reg8(D)),
        0x2B => Sra(Reg8(E)),
        0x2C => Sra(Reg8(H)),
        0x2D => Sra(Reg8(L)),
        0x2E => Sra(RegRef16(HL)),
        0x2F => Sra(Reg8(A)),
        0x30 => Swap(Reg8(B)),
        0x31 => Swap(Reg8(C)),
        0x32 => Swap(Reg8(D)),
        0x33 => Swap(Reg8(E)),
        0x34 => Swap(Reg8(H)),
        0x35 => Swap(Reg8(L)),
        0x36 => Swap(RegRef16(HL)),
        0x37 => Swap(Reg8(A)),
        0x38 => Srl(Reg8(B)),
        0x39 => Srl(Reg8(C)),
        0x3A => Srl(Reg8(D)),
        0x3B => Srl(Reg8(E)),
        0x3C => Srl(Reg8(H)),
        0x3D => Srl(Reg8(L)),
        0x3E => Srl(RegRef16(HL)),
        0x3F => Srl(Reg8(A)),
        0x40 => Bit(0, Reg8(B)),
        0x41 => Bit(0, Reg8(C)),
        0x42 => Bit(0, Reg8(D)),
        0x43 => Bit(0, Reg8(E)),
        0x44 => Bit(0, Reg8(H)),
        0x45 => Bit(0, Reg8(L)),
        0x46 => Bit(0, RegRef16(HL)),
        0x47 => Bit(0, Reg8(A)),
        0x48 => Bit(1, Reg8(B)),
        0x49 => Bit(1, Reg8(C)),
        0x4A => Bit(1, Reg8(D)),
        0x4B => Bit(1, Reg8(E)),
        0x4C => Bit(1, Reg8(H)),
        0x4D => Bit(1, Reg8(L)),
        0x4E => Bit(1, RegRef16(HL)),
        0x4F => Bit(1, Reg8(A)),
        0x50 => Bit(2, Reg8(B)),
        0x51 => Bit(2, Reg8(C)),
        0x52 => Bit(2, Reg8(D)),
        0x53 => Bit(2, Reg8(E)),
        0x54 => Bit(2, Reg8(H)),
        0x55 => Bit(2, Reg8(L)),
        0x56 => Bit(2, RegRef16(HL)),
        0x57 => Bit(2, Reg8(A)),
        0x58 => Bit(3, Reg8(B)),
        0x59 => Bit(3, Reg8(C)),
        0x5A => Bit(3, Reg8(D)),
        0x5B => Bit(3, Reg8(E)),
        0x5C => Bit(3, Reg8(H)),
        0x5D => Bit(3, Reg8(L)),
        0x5E => Bit(3, RegRef16(HL)),
        0x5F => Bit(3, Reg8(A)),
        0x60 => Bit(4, Reg8(B)),
        0x61 => Bit(4, Reg8(C)),
        0x62 => Bit(4, Reg8(D)),
        0x63 => Bit(4, Reg8(E)),
        0x64 => Bit(4, Reg8(H)),
        0x65 => Bit(4, Reg8(L)),
        0x66 => Bit(4, RegRef16(HL)),
        0x67 => Bit(4, Reg8(A)),
        0x68 => Bit(5, Reg8(B)),
        0x69 => Bit(5, Reg8(C)),
        0x6A => Bit(5, Reg8(D)),
        0x6B => Bit(5, Reg8(E)),
        0x6C => Bit(5, Reg8(H)),
        0x6D => Bit(5, Reg8(L)),
        0x6E => Bit(5, RegRef16(HL)),
        0x6F => Bit(5, Reg8(A)),
        0x70 => Bit(6, Reg8(B)),
        0x71 => Bit(6, Reg8(C)),
        0x72 => Bit(6, Reg8(D)),
        0x73 => Bit(6, Reg8(E)),
        0x74 => Bit(6, Reg8(H)),
        0x75 => Bit(6, Reg8(L)),
        0x76 => Bit(6, RegRef16(HL)),
        0x77 => Bit(6, Reg8(A)),
        0x78 => Bit(7, Reg8(B)),
        0x79 => Bit(7, Reg8(C)),
        0x7A => Bit(7, Reg8(D)),
        0x7B => Bit(7, Reg8(E)),
        0x7C => Bit(7, Reg8(H)),
        0x7D => Bit(7, Reg8(L)),
        0x7E => Bit(7, RegRef16(HL)),
        0x7F => Bit(7, Reg8(A)),
        0x80 => Res(0, Reg8(B)),
        0x81 => Res(0, Reg8(C)),
        0x82 => Res(0, Reg8(D)),
        0x83 => Res(0, Reg8(E)),
        0x84 => Res(0, Reg8(H)),
        0x85 => Res(0, Reg8(L)),
        0x86 => Res(0, RegRef16(HL)),
        0x87 => Res(0, Reg8(A)),
        0x88 => Res(1, Reg8(B)),
        0x89 => Res(1, Reg8(C)),
        0x8A => Res(1, Reg8(D)),
        0x8B => Res(1, Reg8(E)),
        0x8C => Res(1, Reg8(H)),
        0x8D => Res(1, Reg8(L)),
        0x8E => Res(1, RegRef16(HL)),
        0x8F => Res(1, Reg8(A)),
        0x90 => Res(2, Reg8(B)),
        0x91 => Res(2, Reg8(C)),
        0x92 => Res(2, Reg8(D)),
        0x93 => Res(2, Reg8(E)),
        0x94 => Res(2, Reg8(H)),
        0x95 => Res(2, Reg8(L)),
        0x96 => Res(2, RegRef16(HL)),
        0x97 => Res(2, Reg8(A)),
        0x98 => Res(3, Reg8(B)),
        0x99 => Res(3, Reg8(C)),
        0x9A => Res(3, Reg8(D)),
        0x9B => Res(3, Reg8(E)),
        0x9C => Res(3, Reg8(H)),
        0x9D => Res(3, Reg8(L)),
        0x9E => Res(3, RegRef16(HL)),
        0x9F => Res(3, Reg8(A)),
        0xA0 => Res(4, Reg8(B)),
        0xA1 => Res(4, Reg8(C)),
        0xA2 => Res(4, Reg8(D)),
        0xA3 => Res(4, Reg8(E)),
        0xA4 => Res(4, Reg8(H)),
        0xA5 => Res(4, Reg8(L)),
        0xA6 => Res(4, RegRef16(HL)),
        0xA7 => Res(4, Reg8(A)),
        0xA8 => Res(5, Reg8(B)),
        0xA9 => Res(5, Reg8(C)),
        0xAA => Res(5, Reg8(D)),
        0xAB => Res(5, Reg8(E)),
        0xAC => Res(5, Reg8(H)),
        0xAD => Res(5, Reg8(L)),
        0xAE => Res(5, RegRef16(HL)),
        0xAF => Res(5, Reg8(A)),
        0xB0 => Res(6, Reg8(B)),
        0xB1 => Res(6, Reg8(C)),
        0xB2 => Res(6, Reg8(D)),
        0xB3 => Res(6, Reg8(E)),
        0xB4 => Res(6, Reg8(H)),
        0xB5 => Res(6, Reg8(L)),
        0xB6 => Res(6, RegRef16(HL)),
        0xB7 => Res(6, Reg8(A)),
        0xB8 => Res(7, Reg8(B)),
        0xB9 => Res(7, Reg8(C)),
        0xBA => Res(7, Reg8(D)),
        0xBB => Res(7, Reg8(E)),
        0xBC => Res(7, Reg8(H)),
        0xBD => Res(7, Reg8(L)),
        0xBE => Res(7, RegRef16(HL)),
        0xBF => Res(7, Reg8(A)),
        0xC0 => Set(0, Reg8(B)),
        0xC1 => Set(0, Reg8(C)),
        0xC2 => Set(0, Reg8(D)),
        0xC3 => Set(0, Reg8(E)),
        0xC4 => Set(0, Reg8(H)),
        0xC5 => Set(0, Reg8(L)),
        0xC6 => Set(0, RegRef16(HL)),
        0xC7 => Set(0, Reg8(A)),
        0xC8 => Set(1, Reg8(B)),
        0xC9 => Set(1, Reg8(C)),
        0xCA => Set(1, Reg8(D)),
        0xCB => Set(1, Reg8(E)),
        0xCC => Set(1, Reg8(H)),
        0xCD => Set(1, Reg8(L)),
        0xCE => Set(1, RegRef16(HL)),
        0xCF => Set(1, Reg8(A)),
        0xD0 => Set(2, Reg8(B)),
        0xD1 => Set(2, Reg8(C)),
        0xD2 => Set(2, Reg8(D)),
        0xD3 => Set(2, Reg8(E)),
        0xD4 => Set(2, Reg8(H)),
        0xD5 => Set(2, Reg8(L)),
        0xD6 => Set(2, RegRef16(HL)),
        0xD7 => Set(2, Reg8(A)),
        0xD8 => Set(3, Reg8(B)),
        0xD9 => Set(3, Reg8(C)),
        0xDA => Set(3, Reg8(D)),
        0xDB => Set(3, Reg8(E)),
        0xDC => Set(3, Reg8(H)),
        0xDD => Set(3, Reg8(L)),
        0xDE => Set(3, RegRef16(HL)),
        0xDF => Set(3, Reg8(A)),
        0xE0 => Set(4, Reg8(B)),
        0xE1 => Set(4, Reg8(C)),
        0xE2 => Set(4, Reg8(D)),
        0xE3 => Set(4, Reg8(E)),
        0xE4 => Set(4, Reg8(H)),
        0xE5 => Set(4, Reg8(L)),
        0xE6 => Set(4, RegRef16(HL)),
        0xE7 => Set(4, Reg8(A)),
        0xE8 => Set(5, Reg8(B)),
        0xE9 => Set(5, Reg8(C)),
        0xEA => Set(5, Reg8(D)),
        0xEB => Set(5, Reg8(E)),
        0xEC => Set(5, Reg8(H)),
        0xED => Set(5, Reg8(L)),
        0xEE => Set(5, RegRef16(HL)),
        0xEF => Set(5, Reg8(A)),
        0xF0 => Set(6, Reg8(B)),
        0xF1 => Set(6, Reg8(C)),
        0xF2 => Set(6, Reg8(D)),
        0xF3 => Set(6, Reg8(E)),
        0xF4 => Set(6, Reg8(H)),
        0xF5 => Set(6, Reg8(L)),
        0xF6 => Set(6, RegRef16(HL)),
        0xF7 => Set(6, Reg8(A)),
        0xF8 => Set(7, Reg8(B)),
        0xF9 => Set(7, Reg8(C)),
        0xFA => Set(7, Reg8(D)),
        0xFB => Set(7, Reg8(E)),
        0xFC => Set(7, Reg8(H)),
        0xFD => Set(7, Reg8(L)),
        0xFE => Set(7, RegRef16(HL)),
        0xFF => Set(7, Reg8(A)),
    }
}

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum Instruction {
    Nop,
    Ld(Operand, Operand),
    Inc(Operand),
    Dec(Operand),
    Add(Operand, Operand),
    Adc(Operand),
    Sub(Operand),
    Sbc(Operand, Operand),
    Mul(Operand, Operand),
    Div(Operand, Operand),
    And(Operand),
    Xor(Operand),
    Or(Operand),
    Cp(Operand),
    Jr(Cond, Operand),
    Jp(Cond, Operand),
    Call(Cond, Operand),
    Ret(Cond),
    Reti,
    Pop(Reg16),
    Push(Reg16),
    Stop,
    Halt,
    Rlca,
    Rrca,
    Rla,
    Rra,
    Daa,
    Cpl,
    Scf,
    Ccf,
    Rst(u8),
    Extended,
    Invalid,
    Ldh(Operand, Operand),
    Di,
    Ei,
    Ldhl,
}

impl Instruction {
    pub fn decode(code: u8) -> Self {
        decode(code)
    }

    pub fn len(&self) -> u16 {
        match self {
            Instruction::Nop => 1,
            Instruction::Ld(operand1, operand2) => operand1.len() + operand2.len(),
            Instruction::Inc(operand) => operand.len(),
            Instruction::Dec(operand) => operand.len(),
            Instruction::Add(operand1, operand2) => operand1.len() + operand2.len(),
            Instruction::Adc(operand) => 1 + operand.len(),
            Instruction::Sub(operand) => operand.len(),
            Instruction::Sbc(operand1, operand2) => operand1.len() + operand2.len(),
            Instruction::Mul(operand1, operand2) => operand1.len() + operand2.len(),
            Instruction::Div(operand1, operand2) => operand1.len() + operand2.len(),
            Instruction::And(operand) => operand.len(),
            Instruction::Xor(operand) => operand.len(),
            Instruction::Or(operand) => operand.len(),
            Instruction::Cp(operand) => operand.len(),
            Instruction::Jr(_cond, operand) => operand.len(),
            Instruction::Jp(_cond, operand) => operand.len(),
            Instruction::Call(_cond, operand) => operand.len(),
            Instruction::Ret(_cond) => 1,
            Instruction::Reti => 1,
            Instruction::Pop(_reg) => 1,
            Instruction::Push(_reg) => 1,
            Instruction::Stop => 1,
            Instruction::Halt => 1,
            Instruction::Rlca => 1,
            Instruction::Rrca => 1,
            Instruction::Rla => 1,
            Instruction::Rra => 1,
            Instruction::Daa => 1,
            Instruction::Cpl => 1,
            Instruction::Scf => 1,
            Instruction::Ccf => 1,
            Instruction::Rst(_addr) => 1,
            Instruction::Extended => 1,
            Instruction::Invalid => 1,
            Instruction::Ldh(operand1, operand2) => operand1.len() + operand2.len(),
            Instruction::Di => 1,
            Instruction::Ei => 1,
            Instruction::Ldhl => 1,
        }
    }
}

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum ExtendedInstruction {
    Rlc(Operand),
    Rrc(Operand),
    Rl(Operand),
    Rr(Operand),
    Sla(Operand),
    Sra(Operand),
    Swap(Operand),
    Srl(Operand),
    Bit(u8, Operand),
    Res(u8, Operand),
    Set(u8, Operand),
}

impl ExtendedInstruction {
    pub fn decode(code: u8) -> Self {
        decode_extended(code)
    }
}

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum Operand {
    Reg8(Reg8),
    RegRef8(Reg8),
    Reg16(Reg16),
    RegRef16(Reg16),
    Imm8,
    Imm8Ref,
    Imm16,
    Imm16Ref,
    Cond(Cond),
}

impl Operand {
    pub fn len(&self) -> u16 {
        match self {
            Operand::Reg8(_reg8) => 0,
            Operand::RegRef8(_reg8) => 0,
            Operand::Reg16(_reg16) => 0,
            Operand::RegRef16(_reg16) => 0,
            Operand::Imm8 => 1,
            Operand::Imm8Ref => 1,
            Operand::Imm16 => 1,
            Operand::Imm16Ref => 1,
            Operand::Cond(_cond) => 0,
        }
    }
}

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum Reg8 {
    A,
    B,
    C,
    D,
    E,
    H,
    L,
}

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum Reg16 {
    BC,
    DE,
    HL,
    HLInc,
    HLDec,
    SP,
    AF,
}

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum Cond {
    ZSet,
    ZReset,
    CSet,
    CReset,
    Always,
}
