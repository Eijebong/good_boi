
pub fn decode(code: u8) -> Instruction {
    use Instruction::*;
    use Operand::*;
    use self::Reg8::*;
    use self::Reg16::*;
    use self::Cond::*;
    
    match code {
        0x00 => Nop,
        0x01 => Ld(Reg16(BC), Imm16),
        0x02 => Ld(RegRef16(BC), Reg8(A)),
        0x03 => Inc(Reg16(BC)),
        0x04 => Inc(Reg8(B)),
        0x05 => Dec(Reg8(B)),
        0x06 => Ld(Reg8(B), Imm8),
        0x07 => Rlca,
        0x08 => Ld(Imm16Ref, Reg16(SP)),
        0x09 => Add(Reg16(HL), Reg16(BC)),
        0x0A => Ld(Reg8(A), RegRef16(BC)),
        0x0B => Dec(Reg16(BC)),
        0x0C => Inc(Reg8(C)),
        0x0D => Dec(Reg8(C)),
        0x0E => Ld(Reg8(C), Imm8),
        0x0F => Rrca,

        0x10 => Stop,
        0x11 => Ld(Reg16(DE), Imm16),
        0x12 => Ld(RegRef16(DE), Reg8(A)),
        0x13 => Inc(Reg16(DE)),
        0x14 => Inc(Reg8(D)),
        0x15 => Dec(Reg8(D)),
        0x16 => Ld(Reg8(D), Imm8),
        0x17 => Rla,
        0x18 => Jr(Always, Reg8(A)),
        0x19 => Add(Reg16(HL), Reg16(DE)),
        0x1A => Ld(Reg8(A), RegRef16(DE)),
        0x1B => Dec(Reg16(DE)),
        0x1C => Inc(Reg8(E)),
        0x1D => Dec(Reg8(E)),
        0x1E => Ld(Reg8(E), Imm8),
        0x1F => Rra,

        0x20 => Jr(ZReset, Imm8),
        0x21 => Ld(Reg16(HL), Imm16),
        0x22 => Ld(RegRef16(HLInc), Reg8(A)),
        0x23 => Inc(Reg16(HL)),
        0x24 => Inc(Reg8(H)),
        0x25 => Dec(Reg8(H)),
        0x26 => Ld(Reg8(H), Imm8),
        0x27 => Daa,
        0x28 => Jr(ZSet, Imm8),
        0x29 => Add(Reg16(HL), Reg16(HL)),
        0x2A => Ld(Reg8(A), RegRef16(HLInc)),
        0x2B => Dec(Reg16(HL)),
        0x2C => Inc(Reg8(L)),
        0x2D => Dec(Reg8(L)),
        0x2E => Ld(Reg8(L), Imm8),
        0x2F => Cpl,

        0x30 => Jr(CReset, Imm8),
        0x31 => Ld(Reg16(SP), Imm16),
        0x32 => Ld(RegRef16(HLDec), Reg8(A)),
        0x33 => Inc(Reg16(SP)),
        0x34 => Inc(RegRef16(HL)),
        0x35 => Dec(RegRef16(HL)),
        0x36 => Ld(RegRef16(HL), Imm8),
        0x37 => Scf,
        0x38 => Jr(CSet, Imm8),
        0x39 => Add(Reg16(HL), Reg16(SP)),
        0x3A => Ld(Reg8(E), RegRef16(HLDec)),
        0x3B => Dec(Reg16(SP)),
        0x3C => Inc(Reg8(A)),
        0x3D => Dec(Reg8(A)),
        0x3E => Ld(Reg8(A), Imm8),
        0x3F => Ccf,

        0x40 => Ld(Reg8(B), Reg8(B)),
        0x41 => Ld(Reg8(B), Reg8(C)),
        0x42 => Ld(Reg8(B), Reg8(D)),
        0x43 => Ld(Reg8(B), Reg8(E)),
        0x44 => Ld(Reg8(B), Reg8(H)),
        0x45 => Ld(Reg8(B), Reg8(L)),
        0x46 => Ld(Reg8(B), RegRef16(HL)),
        0x47 => Ld(Reg8(B), Reg8(A)),
        0x48 => Ld(Reg8(C), Reg8(B)),
        0x49 => Ld(Reg8(C), Reg8(C)),
        0x4A => Ld(Reg8(C), Reg8(D)),
        0x4B => Ld(Reg8(C), Reg8(E)),
        0x4C => Ld(Reg8(C), Reg8(H)),
        0x4D => Ld(Reg8(C), Reg8(L)),
        0x4E => Ld(Reg8(C), RegRef16(HL)),
        0x4F => Ld(Reg8(C), Reg8(A)),

        0x50 => Ld(Reg8(D), Reg8(B)),
        0x51 => Ld(Reg8(D), Reg8(C)),
        0x52 => Ld(Reg8(D), Reg8(D)),
        0x53 => Ld(Reg8(D), Reg8(E)),
        0x54 => Ld(Reg8(D), Reg8(H)),
        0x55 => Ld(Reg8(D), Reg8(L)),
        0x56 => Ld(Reg8(D), RegRef16(HL)),
        0x57 => Ld(Reg8(D), Reg8(A)),
        0x58 => Ld(Reg8(E), Reg8(B)),
        0x59 => Ld(Reg8(E), Reg8(C)),
        0x5A => Ld(Reg8(E), Reg8(D)),
        0x5B => Ld(Reg8(E), Reg8(E)),
        0x5C => Ld(Reg8(E), Reg8(H)),
        0x5D => Ld(Reg8(E), Reg8(L)),
        0x5E => Ld(Reg8(E), RegRef16(HL)),
        0x5F => Ld(Reg8(E), Reg8(A)),

        0x60 => Ld(Reg8(H), Reg8(B)),
        0x61 => Ld(Reg8(H), Reg8(C)),
        0x62 => Ld(Reg8(H), Reg8(D)),
        0x63 => Ld(Reg8(H), Reg8(E)),
        0x64 => Ld(Reg8(H), Reg8(H)),
        0x65 => Ld(Reg8(H), Reg8(L)),
        0x66 => Ld(Reg8(H), RegRef16(HL)),
        0x67 => Ld(Reg8(H), Reg8(A)),
        0x68 => Ld(Reg8(L), Reg8(B)),
        0x69 => Ld(Reg8(L), Reg8(C)),
        0x6A => Ld(Reg8(L), Reg8(D)),
        0x6B => Ld(Reg8(L), Reg8(E)),
        0x6C => Ld(Reg8(L), Reg8(H)),
        0x6D => Ld(Reg8(L), Reg8(L)),
        0x6E => Ld(Reg8(L), RegRef16(HL)),
        0x6F => Ld(Reg8(L), Reg8(A)),

        0x70 => Ld(RegRef16(HL), Reg8(B)),
        0x71 => Ld(RegRef16(HL), Reg8(C)),
        0x72 => Ld(RegRef16(HL), Reg8(D)),
        0x73 => Ld(RegRef16(HL), Reg8(E)),
        0x74 => Ld(RegRef16(HL), Reg8(H)),
        0x75 => Ld(RegRef16(HL), Reg8(L)),
        0x76 => Halt,
        0x77 => Ld(RegRef16(HL), Reg8(A)),
        0x78 => Ld(Reg8(A), Reg8(B)),
        0x79 => Ld(Reg8(A), Reg8(C)),
        0x7A => Ld(Reg8(A), Reg8(D)),
        0x7B => Ld(Reg8(A), Reg8(E)),
        0x7C => Ld(Reg8(A), Reg8(H)),
        0x7D => Ld(Reg8(A), Reg8(L)),
        0x7E => Ld(Reg8(A), RegRef16(HL)),
        0x7F => Ld(Reg8(A), Reg8(A)),

        0x80 => Add(Reg8(A), Reg8(B)),
        0x81 => Add(Reg8(A), Reg8(C)),
        0x82 => Add(Reg8(A), Reg8(D)),
        0x83 => Add(Reg8(A), Reg8(E)),
        0x84 => Add(Reg8(A), Reg8(H)),
        0x85 => Add(Reg8(A), Reg8(L)),
        0x86 => Add(Reg8(A), RegRef16(HL)),
        0x87 => Add(Reg8(A), Reg8(A)),

        0x88 => Adc(Reg8(A), Reg8(B)),
        0x89 => Adc(Reg8(A), Reg8(C)),
        0x8A => Adc(Reg8(A), Reg8(D)),
        0x8B => Adc(Reg8(A), Reg8(E)),
        0x8C => Adc(Reg8(A), Reg8(H)),
        0x8D => Adc(Reg8(A), Reg8(L)),
        0x8E => Adc(Reg8(A), RegRef16(HL)),
        0x8F => Adc(Reg8(A), Reg8(A)),

        0x90 => Sub(Reg8(B)),
        0x91 => Sub(Reg8(C)),
        0x92 => Sub(Reg8(D)),
        0x93 => Sub(Reg8(E)),
        0x94 => Sub(Reg8(H)),
        0x95 => Sub(Reg8(L)),
        0x96 => Sub(RegRef16(HL)),
        0x97 => Sub(Reg8(A)),

        0x98 => Sbc(Reg8(A), Reg8(B)),
        0x99 => Sbc(Reg8(A), Reg8(C)),
        0x9A => Sbc(Reg8(A), Reg8(D)),
        0x9B => Sbc(Reg8(A), Reg8(E)),
        0x9C => Sbc(Reg8(A), Reg8(H)),
        0x9D => Sbc(Reg8(A), Reg8(L)),
        0x9E => Sbc(Reg8(A), RegRef16(HL)),
        0x9F => Sbc(Reg8(A), Reg8(A)),

        0xA0 => And(Reg8(B)),
        0xA1 => And(Reg8(C)),
        0xA2 => And(Reg8(D)),
        0xA3 => And(Reg8(E)),
        0xA4 => And(Reg8(H)),
        0xA5 => And(Reg8(L)),
        0xA6 => And(RegRef16(HL)),
        0xA7 => And(Reg8(A)),

        0xA8 => Xor(Reg8(B)),
        0xA9 => Xor(Reg8(C)),
        0xAA => Xor(Reg8(D)),
        0xAB => Xor(Reg8(E)),
        0xAC => Xor(Reg8(H)),
        0xAD => Xor(Reg8(L)),
        0xAE => Xor(RegRef16(HL)),
        0xAF => Xor(Reg8(A)),

        0xB0 => Or(Reg8(B)),
        0xB1 => Or(Reg8(C)),
        0xB2 => Or(Reg8(D)),
        0xB3 => Or(Reg8(E)),
        0xB4 => Or(Reg8(H)),
        0xB5 => Or(Reg8(L)),
        0xB6 => Or(RegRef16(HL)),
        0xB7 => Or(Reg8(A)),

        0xB8 => Cp(Reg8(B)),
        0xB9 => Cp(Reg8(C)),
        0xBA => Cp(Reg8(D)),
        0xBB => Cp(Reg8(E)),
        0xBC => Cp(Reg8(H)),
        0xBD => Cp(Reg8(L)),
        0xBE => Cp(RegRef16(HL)),
        0xBF => Cp(Reg8(A)),

        0xC0 => Ret(ZReset),
        0xC1 => Pop(DE),
        0xC2 => Jp(ZReset, Imm16),
        0xC3 => Jp(Always, Imm16),
        0xC4 => Call(ZReset, Imm16),
        0xC5 => Push(BC),
        0xC6 => Add(Reg8(A), Imm8),
        0xC7 => Rst(0x00),
        0xC8 => Ret(ZSet),
        0xC9 => Ret(Always),
        0xCA => Jp(ZSet, Imm16),
        0xCB => Extended,
        0xCC => Call(ZSet, Imm16),
        0xCD => Call(Always, Imm16),
        0xCE => Adc(Reg8(A), Imm8),
        0xCF => Rst(0x08),

        0xD0 => Ret(CReset),
        0xD1 => Pop(DE),
        0xD2 => Jp(CReset, Imm16),
        0xD3 => Invalid,
        0xD4 => Call(CReset, Imm16),
        0xD5 => Push(DE),
        0xD6 => Sub(Imm8),
        0xD7 => Rst(0x10),
        0xD8 => Ret(CSet),
        0xD9 => Reti,
        0xDA => Jp(CSet, Imm16),
        0xDB => Invalid,
        0xDC => Call(CSet, Imm16),
        0xDD => Invalid,
        0xDE => Sbc(Reg8(A), Imm8),
        0xDF => Rst(0x18),
        
        0xE0 => Ldh(Imm8Ref, Reg8(A)),
        0xE1 => Pop(HL),
        0xE2 => Ld(RegRef8(C), Reg8(A)),
        0xE3 => Invalid,
        0xE4 => Invalid,
        0xE5 => Push(HL),
        0xE6 => And(Imm8),
        0xE7 => Rst(0x20),
        0xE8 => Add(Reg16(SP), Imm8),
        0xE9 => Jp(Always, RegRef16(HL)),
        0xEA => Ld(Imm16Ref, Reg8(A)),
        0xEB => Invalid,
        0xEC => Invalid,
        0xED => Invalid,
        0xEE => Xor(Imm8),
        0xEF => Rst(0x28),

        0xF0 => Ldh(Reg8(A), Imm8Ref),
        0xF1 => Pop(AF),
        0xF2 => Ld(Reg8(A), RegRef8(C)),
        0xF3 => Di,
        0xF4 => Invalid,
        0xF5 => Push(AF),
        0xF6 => Or(Imm8),
        0xF7 => Rst(0x30),
        0xF8 => Ldhl,
        0xF9 => Ld(Reg16(SP), Reg16(HL)),
        0xFA => Ld(Reg8(A), Imm16Ref),
        0xFB => Ei,
        0xFC => Invalid,
        0xFD => Invalid,
        0xFE => Cp(Imm8),
        0xFF => Rst(0x38),
    }
}

#[derive(Debug)]
pub enum Instruction {
    Nop,
    Ld(Operand, Operand),
    Inc(Operand),
    Dec(Operand),
    Add(Operand, Operand),
    Adc(Operand, Operand),
    Sub(Operand),
    Sbc(Operand, Operand),
    Mul(Operand, Operand),
    Div(Operand, Operand),
    And(Operand),
    Xor(Operand),
    Or(Operand),
    Cp(Operand),
    Jr(Cond, Operand),
    Jp(Cond, Operand),
    Call(Cond, Operand),
    Ret(Cond),
    Reti,
    Pop(Reg16),
    Push(Reg16),
    Stop,
    Halt,
    Rlca,
    Rrca,
    Rla,
    Rra,
    Daa,
    Cpl,
    Scf,
    Ccf,
    Rst(u8),
    Extended,
    Invalid,
    Ldh(Operand, Operand),
    Di,
    Ei,
    Ldhl,
}

impl Instruction {
    pub fn decode(code: u8) -> Self {
        decode(code)
    }
}

#[derive(Debug)]
pub enum Operand {
    Reg8(Reg8),
    RegRef8(Reg8),
    Reg16(Reg16),
    RegRef16(Reg16),
    Imm8,
    Imm8Ref,
    Imm16,
    Imm16Ref,
    Cond(Cond),
}

#[derive(Debug)]
pub enum Reg8 {
    A,
    B,
    C,
    D,
    E,
    H,
    L,
}

#[derive(Debug)]
pub enum Reg16 {
    BC,
    DE,
    HL,
    HLInc,
    HLDec,
    SP,
    AF,
}

#[derive(Debug)]
pub enum Cond {
    ZSet,
    ZReset,
    CSet,
    CReset,
    Always,
}
